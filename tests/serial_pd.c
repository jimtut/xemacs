/******************************************************************** * Copyright (C)  Data General Corporation 1997 * All rights reserved.  Licensed material - property * of Data General Corporation. ********************************************************************//******************************************************************** *   FILE:			serial_pd.c ******************************************************************** * * Description: This K2 file contains functions for the Serial *				Presence Detect EEPROM data on the DIMMs. * * History: *  2.1  06/11/97 Created - KTK *	2.2  07/31/97 Corrected Acknowledge for reads, changed the name *				  of spd_setup_write() to spd_setup() - KTK *	2.4  08/11/97 added volatile to registers for optimization. - KTK *********************************************************************/#include "generics.h"#include "lru_reg.h"#include "serial_pd.h"#include "diag_error.h"/* Function prototypes */UINT_8E	spd_random_read(UINT_32, UINT_8E);VOID 	spd_setup(UINT_32, UINT_8E);UINT_8E spd_initial_read(UINT_32, UINT_8E);UINT_8E spd_continued_read(UINT_8E);VOID 	spd_full_read(UINT_32, SERIAL_PD_DATA*);/****************************************************************** * 				UINT_8E spd_random_read() ****************************************************************** * Description: * 	This function performs the I2C protocol random read operation, *	then reads the data one bit at a time into a UINT_8E and returns *	that to the caller. *  * Parameters: * 		UINT_32 dimm		- the dimm to reference *		UINT_8E data_addr	- the address of the place in the EEPROM to read *  * Returns: * 		UINT_8E				- data from the read done on the EEPROM *****************************************************************/UINT_8E spd_random_read(UINT_32 dimm, UINT_8E data_addr){	register volatile UINT_8E *spd_out;		/* variable for referencing the output register */	register UINT_8E returned_data;	/* data to be returned */		spd_out = (UINT_8E *) LRU_SPD_DATA_OUT;		spd_setup(dimm, data_addr);	/* start the random read */										/* at data address given */		returned_data = spd_initial_read(dimm, SPD_DONE);	return(returned_data);}	/* spd_random_read() *//****************************************************************** * 						VOID spd_setup() ****************************************************************** * Description: * 	This function tells the eeprom where to position it's pointer * 	to the data, and sets up a write to it. *  * Parameters: * 		UINT_32 dimm				- the dimm to reference * 		UINT_8E word_addr			- address of the data on the eeprom *  * Returns: * 		void *****************************************************************/VOID spd_setup(UINT_32 dimm, UINT_8E word_addr){	register UINT_8E wr_slave_addr;	/* set up device type and read/write */										/* operation bits */	register INT_32 countBits;		/* count for accessing individual */										/* bits in a byte */	register volatile UINT_8E *spd_out;		/* variable for referencing the */										/* output register */	register volatile UINT_8E *spd_in;		/* variable for referencing the */										/* input register */	register UINT_8E dummy_var;		/* variable used in performing a */										/* read on the EEPROM */	spd_out = (UINT_8E *) LRU_SPD_DATA_OUT;	spd_in = (UINT_8E *) LRU_SPD_DATA_IN;	wr_slave_addr = EEPROM_WRITE_DEVICE_TYPE | (dimm << 1);  /* now it also holds the dimm # */	/* first we send a start condition */	*spd_out = SPD_START_BIT;	/* now we output the slave address to LRU_SPD_DATA_OUT one bit at a time */	for (countBits = 7; countBits >= 0; countBits--)	{		*spd_out = (wr_slave_addr >> countBits) & DATA_OUT_MASK;	}wait_us(100); /* TEST ONLY */	/* now we do an ACK */	dummy_var = *spd_in;wait_us(100); /* TEST ONLY */		/* now we output the address of the data on the EEPROM */	for (countBits = 7; countBits >= 0; countBits--)	{		*spd_out = (word_addr >> countBits) & DATA_OUT_MASK;	}wait_us(100); /* TEST ONLY */	/* now another ACK */	dummy_var = *spd_in;wait_us(100); /* TEST ONLY */}	/* spd_setup() *//****************************************************************** * 				UINT_32 spd_write() ****************************************************************** * Description: * 	This function actually writes information to the EEPROM. * 	Writing data to the eeprom can be dangerous, so use caution * 	when using this function.  It will not accept addresses to * 	access below address 128, if so, it will return ERROR. *  * Parameters: * 		UINT_32	dimm * 		UINT_8E word_addr *  * Returns: * 		UINT_32				- error condition or not. *  ******************************************************************/UINT_32 spd_write(UINT_32 dimm, UINT_8E word_addr, UINT_8E write_data){	register volatile UINT_8E *spd_out;		/* variable for referencing the */										/* output register */	register volatile UINT_8E *spd_in;		/* variable for referencing the */										/* input register */	register INT_32 countBits;	register UINT_8E dummy_var;		/* variable used in performing a */										/* read on the EEPROM */	spd_out = (UINT_8E *) LRU_SPD_DATA_OUT;	spd_in = (UINT_8E *) LRU_SPD_DATA_IN;	if(word_addr < EEPROM_PROTECTED_DATA)	{		return ERROR;	}	else	{		spd_setup(dimm,word_addr);		/* write the data out */		for(countBits = 7; countBits >= 0; countBits--)		{			*spd_out = (write_data >> countBits) & DATA_OUT_MASK;		}wait_us(100); /* TEST ONLY */ /* TEST ONLY */		dummy_var = *spd_in;		/* just accept acknowledge */wait_us(100); /* TEST ONLY */		*spd_out = SPD_STOP_BIT;	/* we're finished now */		return NO_ERROR;			/* write was fine */	} /* end ifelse */}	/* spd_write() *//****************************************************************** * 				UINT_8E spd_initial_read() ****************************************************************** * Description: * 	This function does the initial setup for a read, and reads a *  byte of data from the EEPROM on the DIMMs bit by bit and stores * 	it in a UINT_8E, and then returns that, when filled, to the  *  caller. *  * (we are assuming that address positioning is already set for us, *  i.e. a call to spd_setup was made) *  * Parameters: * 		UINT_32 dimm				- address of dimm to read from *		UINT_8E flag				- flag indicating whether we are going to *									  continue to read, or end here. *  * Returns: * 		UINT_8E						- data from the read done on the EEPROM *  *****************************************************************/UINT_8E spd_initial_read(UINT_32 dimm, UINT_8E flag){	register UINT_8E slave_addr;		/* set up device type and read/write */											/* operation bits */	register INT_32 countBits;			/* count for accessing individual */											/* bits in a byte */	register UINT_8E eeprom_data = 0;	/* data from the EEPROM that */											/* will be returned */	register volatile UINT_8E *spd_out;	/* variable for referencing the */											/* output register to the eeprom */	register volatile UINT_8E *spd_in;	/* variable for referencing the */											/* input register to the eeprom */	register UINT_8E dummy_var;			/* variable used in performing */											/* a read on the EEPROM */	spd_out = (UINT_8E *) LRU_SPD_DATA_OUT;	spd_in  = (UINT_8E *) LRU_SPD_DATA_IN;	*spd_out = SPD_START_BIT;	/* send start condition to start a read */	slave_addr = EEPROM_READ_DEVICE_TYPE | (dimm << 1); /* dimm type, dimm, and read */		/* now we output the slave address with */	/* the last bit set to 1 to indicate a read. */	for (countBits = 7 ; countBits >= 0; countBits--)	{		*spd_out = (slave_addr >> countBits) & DATA_OUT_MASK;	}	wait_us(100); /* TEST ONLY */	/* now we do an ACK */	dummy_var = *spd_in;wait_us(100); /* TEST ONLY */	/* here we actually get the data and put it into the eeprom_data buffer */	for (countBits = 7 ; countBits >= 0; countBits--)	{		eeprom_data <<= 1;		eeprom_data |= *spd_in;	}wait_us(100); /* TEST ONLY */	*spd_out = flag;wait_us(100); /* TEST ONLY */	if (flag == SPD_DONE)	{		*spd_out = SPD_STOP_BIT;	/* issue stop condition to */									/* indicate finished with read */	}	return(eeprom_data);}	/* spd_initial_read() *//****************************************************************** * 				UINT_8E spd_continued_read() ****************************************************************** * Description: * 	This function reads a byte of data from the EEPROM on the DIMMs *  bit by bit and stores it in a UINT_8E, and then returns that, *  when filled, to the caller. *  * (we are assuming that address positioning is already set for us, * and an initial read was allready performed.) *  * Parameters: *		UINT_8E flag		- flag indicating whether we are going *							  to continue to read, or end here. *  * Returns: * 		UINT_8E				- data from the read done on the EEPROM *  ******************************************************************/UINT_8E spd_continued_read(UINT_8E flag){	register INT_32 countBits;			/* count for accessing individual */											/* bits in a byte */	register UINT_8E eeprom_data = 0;	/* data from the EEPROM that */											/* will be returned */	register volatile UINT_8E *spd_in;	/* variable for referencing the */											/* input register to the eeprom */	register volatile UINT_8E *spd_out;	/* variable for referencing the */											/* output register to the eeprom */	spd_in  = (UINT_8E *) LRU_SPD_DATA_IN;	spd_out  = (UINT_8E *) LRU_SPD_DATA_OUT;	/* here we actually get the data and put it into the eeprom_data buffer */	for (countBits = 7 ; countBits >= 0; countBits--)	{		eeprom_data <<= 1;		eeprom_data |= *spd_in;	}	wait_us(100); /* TEST ONLY */	*spd_out = flag;wait_us(100); /* TEST ONLY */	if (flag == SPD_DONE)	{		*spd_out = SPD_STOP_BIT;	}	return(eeprom_data);}	/* spd_continued_read *//****************************************************************** * 				VOID spd_full_read() ****************************************************************** * Description: * 	This function reads the data contained within the specified * 	DIMM's EEPROM, and fills in the structure passed to it with * 	that data. * * 	Parameters: * 		UINT_32 dimm        		- address of dimm to read from * 		SERIAL_PD_DATA *spd_data	- pointer to structure to fill in *  * 	Returns: * 		void *  *****************************************************************/VOID spd_full_read(UINT_32 dimm, SERIAL_PD_DATA *spd_data){	register volatile UINT_8E *spd_out;			/* variable for referencing the */											/* output register to the eeprom */	spd_out = (UINT_8E *) LRU_SPD_DATA_OUT;		spd_setup(dimm, 0);	/* first we specify to start the */								/* sequential read at data address 0 */	/* then we start reading in the data sequentially */	spd_data->module_manufacturer = spd_initial_read(dimm, SPD_CONTINUE);	spd_data->spd_mem_size  	  = spd_continued_read(SPD_CONTINUE);	spd_data->fund_mem_type 	  = spd_continued_read(SPD_CONTINUE);	spd_data->row_addresses 	  = spd_continued_read(SPD_CONTINUE);	spd_data->col_addresses 	  = spd_continued_read(SPD_CONTINUE);	spd_data->num_banks     	  = spd_continued_read(SPD_CONTINUE);	spd_data->data_width		  = spd_continued_read(SPD_CONTINUE);	spd_data->data_width		  = (spd_data->data_width << 8) | 									spd_continued_read(SPD_CONTINUE);  /* second byte for data width */	spd_data->volt_interface	  = spd_continued_read(SPD_CONTINUE);	spd_data->ras_acc_time		  = spd_continued_read(SPD_CONTINUE);	spd_data->cas_acc_time		  = spd_continued_read(SPD_CONTINUE);	spd_data->error_scheme		  = spd_continued_read(SPD_CONTINUE);	spd_data->refresh_rate_type	  = spd_continued_read(SPD_CONTINUE);	spd_data->primary_dram_width  = spd_continued_read(SPD_CONTINUE);	spd_data->errorchk_dram_width = spd_continued_read(SPD_DONE);	return;}	/* spd_full_read() */